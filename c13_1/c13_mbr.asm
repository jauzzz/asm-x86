        core_base_address equ 0x00040000    ; 内核的内存起始地址
        core_start_sector equ 0x00000001    ; 内核的起始逻辑扇区号



;===============================================================================
; 该引导程序主要完成的工作是:
;   进入保护模式
;       建立全局描述符表
;       打开 A20
;       关闭中断
;       设置 CR0
;       清空流水线并串行化处理器
;   加载内核
;       加载内核代码到内存中
;       为内核建立对应的描述符
;       刷新全局描述符表寄存器
;   加载和重定向用户程序
;===============================================================================



;===================================== 首先要进入保护模式 =====================================

        ;开机的时候，计算机的 CS:IP 会指向 0xFFFF:0000
        ;0xFFFF:0000 被地址控制器映射到 BIOS-ROM，然后对应的指令会跳转到 BIOS-ROM 的低地址执行
        ;BIOS ROM 的主要工作是：硬件的检测、诊断和初始化，并提供与外围设备交互的例程
        ;当主要工作完成后，就会从硬盘加载主引导程序到 0x07c00 物理地址，并跳转到这里，把控制权交给主引导程序        
        ;所以，执行主引导程序时，cs:ip = 0x07c0:0000

        ;进入保护模式，步骤如下:
        ;   - 建立全局描述符表（保护模式的寻址通过描述符来进行，CPU通过全局描述符表来转换描述符和对应的物理地址之间的关系）
        ;   - 打开 A20
        ;   - 关闭中断 （保护模式下的中断机制与实模式不同，因此原有的中断向量表不再适用，需要重新建立）
        ;   - 打开 PE位（CR0寄存器的位0）
        ;   - 清空流水线并串行化处理器



        ;----------------------------- Step1: 建立全局描述符表 ------------------------------
        ;   首先需要明确，什么是保护模式？
        ;   保护模式就是通过段选择子来访问内存，段选择子会通过段描述符获取到相应的物理地址，如果物理地址超过段描述符的限制，就会产生内部中断，从而达到保护的功能
        ;   为了保存段描述符，在内存中开辟了一段空间集中存放，称为描述符表（分为全局描述符表、局部描述符表）
        ;
        ;   - 首先需要知道全局描述符表的物理内存地址（规定是在 0x7e00，安排在主引导程序的上方，因为主引导大小为 512 字节，即 0x7c00 + 512 = 0x7e00)
        ;   - 一个段描述符为 64 位，大小为 8 字节
        ;   - 处理器通过 GDTR 来跟踪段描述符表（48位：32位段基地址 + 16位段界限）
        ;   - 所以 GDT 最大可以有 2^16 = 65536 Byte(字节) = 64KB，最多可以有 65536/8 = 8192 个描述符
        ;   - 建立完全局段描述符后需要修改对应的全局描述符表信息（主要是段界限），然后将最新的全局描述符表信息加载到 GDT 寄存器

        ;首先要获取 gdt 的物理地址，将其赋值给 ds 寄存器
        ;32位CPU，即使不在保护模式下，也可以使用32位的指令，实模式/保护模式只影响寻址方式
        ;32位CPU，在实模式下，主引导程序的加载地址是 0x0000:0x7c00
        ;
        ;要将32位的物理地址转换为16位的逻辑地址【段地址:偏移地址】
        ; 32位除法：
        ;   被除数为32位，除数为16位
        ;   被除数的高16位存放在dx，低16位存放在ax
        ;   结果的商存在ax，余数存在dx
        mov ax,cs
        mov ss,ax
        mov sp,0x7c00

        mov eax, [cs:pgdt+0x7c00+0x02]
        xor edx, edx
        mov ebx, 16
        div ebx

        mov ds, eax
        mov ebx, edx

        ;描述符0是空描述符
        ; mov dword [ebx], 0x00
        ; mov dword [ebx+0x04], 0x00

        ;描述符1是数据段描述符
        ;其起始地址是 0x0000, 段界限为 0xFFFFF, 粒度为KB, 总大小为 4GB
        mov dword [ebx+0x08], 0x0000ffff
        mov dword [ebx+0x0c], 0x00cf9200

        ;描述符2是代码段描述符
        ;其起始地址是 0x7c00, 段界限为 0x1FF, 粒度为KB，总大小为 512KB
        mov dword [ebx+0x10], 0x7c0001ff
        mov dword [ebx+0x14], 0x00409800

        ;描述符3是栈段描述符
        ;其起始地址是 0x7c00, 段界限为 0xFFFFE，粒度为 4KB，总大小为 4KB，内存范围是 0x00006C00 ~ 0x00007C00
        ;栈段的段界限，计算方式不同，因为栈段是往下行进的:
        ;   如果粒度为字节时，实际的段界限就是描述符中的段界限
        ;   如果粒度为4KB时，实际的段界限就是 描述符中的段界限 * 0x1000 + 0xFFF
        ;
        ;   故，当前栈段的实际段界限为 0xFFFFE * 0x1000 + 0xFFF = 0xFFFFEFFF
        ;   而栈段的实际段界限要满足条件：（实际段界限 + 1）<= (ESP - 操作数长度) <= 0xFFFFFFFF （ESP的最大值）
        ;   即，0xFFFFF000 <=  (ESP - 操作数长度) <= 0xFFFFFFFF
        ;   所以最低端的栈段地址是：栈段基地址 + 0xFFFFF000 = 0x00007C00 + 0xFFFFF000 = 0x00006C00
        mov dword [ebx+0x18], 0x7c00fffe
        mov dword [ebx+0x1c], 0x00cf9600

        ;描述符4是显示缓冲区描述符
        ;基地址为0x000B8000，界限0x07FFF，粒度为字节
        mov dword [ebx+0x20], 0x80007fff
        mov dword [ebx+0x24], 0x0040920b

        ;至此，描述符建立完成，更新 pgdt 的边界值
        ;段的边界值 = 段的数量 * 8 -1
        mov word [cs:pgdt+0x7c00], 39

        ;将全局描述符表信息，加载到 gdt 寄存器
        lgdt [cs:pgdt+0x7c00]

        ;----------------------------- Step2: 打开 A20 ------------------------------
        ;打开 A20，就是将端口 0x92 的位1 置 1
        in al, 0x92
        or al, 0000_0010B
        out 0x92, al

        ;----------------------------- Step3: 关闭中断 ------------------------------
        cli

        ;----------------------------- Step4: 打开PE位 （CR0 寄存器的位0） ------------------------------
        mov eax, cr0
        or eax, 1
        mov cr0, eax

        ;----------------------------- Step5: 清空流水线、串行化处理器 ------------------------------
        ;通过一个跳转命令来完成
        jmp dword 0x0010:flush

        [bits 32]



;===================================== 然后就是加载内核 =======================================
    flush:
        ;加载内核就是把内核代码，从扇区加载到内存，并为内核建立所需的段描述符
        ;   - 加载代码
        ;   - 建立描述符
        ;   - 刷新全局描述符表寄存器
        
        ;----------------------------- Step1: 加载内核代码 ------------------------------     
        ;初始化栈段，因为下面有 call 调用（栈段的索引号为 3）
        mov eax, 0x0018
        mov ss, eax
        xor esp, esp

        ;初始化数据段，因为读取扇区，需要加载数据到内存（数据段的索引号为 1）
        mov eax, 0x0008
        mov ds, eax

        ;先读取一个扇区的数据（由于是call调用，需要检查栈段是否已初始化）
        ;调用前构造参数
        mov eax, core_start_sector
        mov edi, core_base_address
        mov ebx, edi

        call read_hard_disk_0

        ;根据加载到的内核代码头部信息（有内核代码长度的信息），判断还要加载多少个扇区
        ;计算公式是：内核代码长度 / 扇区大小（512字节）= 总加载扇区数量
        ;
        ;如果除数是8位，被除数就是16位，位于寄存器ax，商在寄存器al，余数在寄存器ah
        ;如果除数是16位，被除数就是32位，高16位在dx，低16位在ax，商在ax，余数在dx
        ;如果除数是32位，被除数是64位，高32位在edx，低32位在eax，商在寄存器eax，余数在edx        
        mov eax, [edi]
        xor edx, edx
        mov ecx, 512
        div ecx

        ;商：需要加载的总扇区数（要注意到当前已经加载了一个扇区）
        ;余数：如果余数不为0，则需要额外加载一个扇区（因为硬盘的读写是以扇区为基本单位的）
        
        or edx, edx
        jnz @1
        dec eax

	; edx 不为0，即需要额外加载一个扇区，与已加载的一个扇区抵消了，故继续加载 eax 次即可
	@1:
		or eax, eax
		jz setup

		mov ecx, eax

		;由于eax中逻辑扇区号的值被除法覆盖，所以重新获取一次
		mov eax, core_start_sector
		inc eax

	@2:
		call read_hard_disk_0
		inc eax
		loop @2

	;加载完后，就是建立内核对应的段描述符
	setup:
		;内核代码一共定义了六个段
        ;   0x08: 整个0-4GB内存的段的选择子 (该段已定义)
        ;   0x18: 内核堆栈段选择子 (该段已定义)
        ;   0x20: 显示缓冲区的段选择子 (该段已定义)
        ;   0x28: 系统公共例程代码段的选择子 
        ;   0x30: 内核数据段选择子 
        ;   0x38: 内核代码段选择子
        ;
		mov esi,[0x7c00+pgdt+0x02]

		;首先建立系统公共例程段的描述符
		;获取段基地址（起始汇编地址）
		mov eax, [edi+0x04]
		;获取段界限：通过相邻段的基地址相减获取段长度，段界限=段长度-1
		mov edx, [edi+0x08]
		sub edx, eax
		dec edx
		;获取实际段基地址（起始汇编地址 + 段的物理内存地址）
		add eax, edi
		;构造段属性
		mov ecx,0x00409800
		;调用 make_gdt_descriptor 方法
		call make_gdt_descriptor
		;回写全局描述符表
		mov [esi+0x28],eax
        mov [esi+0x2c],edx

		;建立核心数据段描述符
		mov eax,[edi+0x08]
		mov ebx,[edi+0x0c]
		sub ebx,eax
		dec ebx
		add eax,edi
		mov ecx,0x00409200
		call make_gdt_descriptor
		mov [esi+0x30],eax
		mov [esi+0x34],edx

		;建立核心代码段描述符
		mov eax,[edi+0x0c]
		mov ebx,[edi+0x00]
		sub ebx,eax
		dec ebx
		add eax,edi
		mov ecx,0x00409800
		call make_gdt_descriptor
		mov [esi+0x38],eax
		mov [esi+0x3c],edx

		;更新pgdt的界限值
		mov word [0x7c00+pgdt],63

		;重新加载lgdt        
		lgdt [pgdt+0x7c00]

		;执行内核代码
		jmp far [edi+0x10]

;===================================== 这里是辅助方法 =======================================
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;EAX=逻辑扇区号
                                         ;DS:EBX=目标缓冲区地址
                                         ;返回：EBX=EBX+512
         push eax 
         push ecx
         push edx
      
         push eax
         
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数

         inc dx                          ;0x1f3
         pop eax
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov cl,8
         shr eax,cl
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         shr eax,cl
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         shr eax,cl
         or al,0xe0                      ;第一硬盘  LBA地址27~24
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al

  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov ecx,256                     ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [ebx],ax
         add ebx,2
         loop .readw

         pop edx
         pop ecx
         pop eax
      
         ret

;-------------------------------------------------------------------------------
make_gdt_descriptor:                     ;构造描述符
                                         ;输入：EAX=线性基地址
                                         ;      EBX=段界限
                                         ;      ECX=属性（各属性位都在原始
                                         ;      位置，其它没用到的位置0） 
                                         ;返回：EDX:EAX=完整的描述符
         mov edx,eax
         shl eax,16                     
         or ax,bx                        ;描述符前32位(EAX)构造完毕
      
         and edx,0xffff0000              ;清除基地址中无关的位
         rol edx,8
         bswap edx                       ;装配基址的31~24和23~16  (80486+)
      
         xor bx,bx
         or edx,ebx                      ;装配段界限的高4位
      
         or edx,ecx                      ;装配属性 
      
         ret


;-------------------------------------------------------------------------------
         pgdt             dw 0
                          dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------
         times 510-($-$$) db 0
                          db 0x55,0xaa      ;主引导扇区标志位
