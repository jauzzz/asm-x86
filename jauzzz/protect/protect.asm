        ;文件名: mbr.asm
        ;文件说明: 保护模式的硬盘主引导扇区代码

        ; ====
        ; 保护模式: 对内存的访问进行保护
        ; 如何实现？
        ;   程序要登记需要使用的段，非自己的段会被拒绝访问
        ;   登记的内容包括：段的起始地址，段的各种访问属性
        ;   当程序访问的地址超出范围时，处理器会阻止这种访问，并产生一个内部异常的中断
        ;
        ; 段的信息，通过段描述符来组织，共 8 个字节
        ; 段描述符会集中存放在一个地方，称为段描述符表
        ; 描述符表 = 段基址 + 段界限
        ;
        ; 为了跟踪全局描述符表，处理器内部有一个 48 位寄存器，称为 GDTR（全局描述符表寄存器）
        ; 该寄存器分为两部分，分别是 32 位的线性地址和 16 位的边界
        ; 一个段描述符共 64 比特，即 8 字节，所以全局描述符表一共能定义 8192 个描述符
        ;
        ; 理论上，全局描述符表可以位于内存中的任何地方；
        ; 但是，由于在进入保护模式之后，处理器要立刻按照新的内存访问方式工作
        ; 所以，必须在进入保护模式之前，建立好 GDT（全局描述符表）
        ; 而实模式可允许的内存范围只有 1MB，所以全局描述符表通常定义在 1MB 以下的内存范围中。
        ; 对应的，可以在进入保护模式之后，重新换个地方建立全局描述符表
        ;
        ; ====
        ; 那么如何进入保护模式？
        ;     1. 建立 GDT 和 GDTR
        ;     2. 打开 A20
        ;     3. 禁止中断
        ;     4. 设置 CR0 PE 位，进入保护模式
        ;     5. 清空流水线并串行化处理器

        ;设置堆栈段和栈指针 
        mov ax, cs
        mov ss, ax
        mov sp, 0x7c00

        ; 将 gdt 物理地址换算成段地址
        mov ax, [cs:gdt_base+0x7c00]
        mov dx, [cs:gdt_base+0x7c00+0x02]
        mov bx, 16
        div bx
        ; ax = 段地址，bx = 偏移地址
        mov ds, ax
        mov bx, dx

        ; 建立 GDT
        ; 我们要把这个引导程序使用到的段，进行登记
        ;
        ; 引导程序使用到的段有：
        ;     - 代码段
        ;     - 数据段
        ;     - 栈段
        ;
        ; 段描述符的格式:
        ;     - 段基地址
        ;     - 段界限
        ;     - G（粒度位）: 用于解释段界限的含义。当 G=0 时，段界限以字节为单位；当 G=1 时，段界限以 4KB 为单位
        ;     - D/B（默认的操作数大小）: 该标志位对于不同的段有不同的效果。
        ;                            对于代码段，此位为 D 位，用于指示指令中默认的偏移地址和操作数尺寸。
        ;                            D=0，表示指令中的偏移地址或操作数是 16 位的；D=1，表示是 32 位的。
        ;                            对于栈段，此位为 B 位，用于指示进行栈操作时，是使用 SP 寄存器还是 ESP。
        ;                            如果 B=0，表示使用 SP；B=1，表示使用 ESP。
        ;                            同时，B的值也决定了栈的上部边界。
        ;                            如果 B=0，那么栈的上部边界是 0xFFFF；B=1，上部边界是 0xFFFFFFFF。
        ;     - L（64位代码段标志）
        ;     - AVL（软件可使用的位）: 通常由操作系统来用，处理器并不使用它
        ;     - P（段存在位）: 用于指示描述符所对应的段是否存在。
        ;                    一般来说，描述符所指示的段都在内存中，但内存紧张时，有可能只建立了描述符，未加载到内存
        ;                    此时，需要将很少用到的段换出到硬盘，腾出空间给新段使用。
        ;                    P 位是由处理器负责检查的;
        ;                    每当描述符访问段时，如果它的 P=0，处理器就会产生异常中断。
        ;     - DPL（特权级）: 共有 0、1、2、3 四种特权级；
        ;                    不同特权级的程序是相互隔离的，其访问是严格控制的，且（出于安全）有些指令只能由特权级为 0 的程序来执行；
        ;                    刚进入保护模式时执行的代码具有最高特权级 0
        ;     - S（描述符类型）: 当 S=0 时，表示是一个系统段；当 S=1 时，表示是一个代码段/数据段
        ;     - TYPE（类别）：共4位，用于指示描述符的子类型
        ;                   对于数据段来说，这 4 位是 X、E、W、A；
        ;                   对于代码段来说，这 4 位是 X、C、R、A；
        ;
        ;                   X: 是否可执行；数据段总是不可执行的，X=0；代码段总是可执行的。
        ;                   E: 对于数据段来说，E 表示段的扩展方向。
        ;                      E=0 向上扩展，也就是向高地址方向扩展，是普通的数据段。
        ;                      E=1 向下扩展，也就是向低地址方向扩展，通常是栈段。
        ;                   W: 是否可写；W=0 表示不可写，若尝试写入会引发处理器异常中断。
        ;                   C: 是否特权级已从；
        ;                      C=0 表示非依从，即该代码段只可以由相同特权级的代码段调用，或通过门调用；
        ;                      C=1 表示可依从，即允许低特权级代码转移到该段执行。
        ;                   R: 是否可读；R=0 表示不可读，即程序和指令没法读取该段的内容，但不限制处理器。
        ;                   A: 已访问位；用于指示最近创建的段是否被访问过。

        ; #0 空描述符，这是一个规定
        mov dword [bx+0x00], 0x00
        mov dword [bx+0x04], 0x00

        ; #1 代码段描述符
        ;     - 段基地址: 0x00007c00
        ;     - 段界限: 512 字节-1 = 0x200-1 = 0x1FF
        ;     - G=0
        ;     - D/B=1
        ;     - L=0; AVL=0
        ;     - P=1; DPL=0; S=1
        ;     - TYPE=1000
        mov dword [bx+0x08], 0x7c0001ff
        mov dword [bx+0x0c], 0x00409800

        ; 2#描述符，是数据段描述符 (文本模式下的显示缓冲区)
        ;     - 段基地址: 0x000b8000
        ;     - 段界限: 0x0FFFF
        ;     - G=0
        ;     - D/B=1
        ;     - L=0; AVL=0
        ;     - P=1; DPL=0; S=1
        ;     - TYPE=0010
        mov dword [bx+0x10], 0x8000ffff     
        mov dword [bx+0x14], 0x0040920b

        ; 3#描述符，是堆栈描述符 (从 0x7a00 到 0x7c00) 
        ;     - 段基地址: 0x00000000
        ;     - 段界限: 0x7A00
        ;     - G=0
        ;     - D/B=1
        ;     - L=0; AVL=0
        ;     - P=1; DPL=0; S=1
        ;     - TYPE=0010
        mov dword [bx+0x18], 0x00007a00
        mov dword [bx+0x1c], 0x00409600

        ; 建立 GDTR（通过 lgdt 指令）
        ;
        ; 描述符表的界限（总字节数减一）
        mov word [cs: gdt_size+0x7c00], 31        
        ; GDT 的基地址被设定为 0x00007e00，我们用一个标号 gdt_base 指定它
        lgdt [cs:gdt_size+0x7c00]

        ; 打开 A20
        in al, 0x92
        or al, 0000_0010B
        out 0x92, al

        ; 禁止中断
        cli

        ; 设置 CR0 的 PE 位
        mov eax, cr0
        or eax, 1
        mov cr0, eax

        ; 清空流水线并串行化处理器
        ; 可以通过一个跳转命令来实现
        jmp dword 0x0008:flush

        ; NOTE: 此处是伪指令，通知编译器按照 32位操作数模式进行编译（因为已经进入了保护模式了）
        [bits 32]

flush:
        ; 指定数据段
        mov cx, 00000000000_10_000B
        mov ds, cx

        ;以下在屏幕上显示"Protect mode OK." 
        mov byte [0x00],'P'  
        mov byte [0x02],'r'
        mov byte [0x04],'o'
        mov byte [0x06],'t'
        mov byte [0x08],'e'
        mov byte [0x0a],'c'
        mov byte [0x0c],'t'
        mov byte [0x0e],' '
        mov byte [0x10],'m'
        mov byte [0x12],'o'
        mov byte [0x14],'d'
        mov byte [0x16],'e'
        mov byte [0x18],' '
        mov byte [0x1a],'O'
        mov byte [0x1c],'K'

        ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
        mov cx, 00000000000_11_000B         ;加载堆栈段选择子
        mov ss, cx
        mov esp, 0x7c00

        mov ebp, esp                        ;保存堆栈指针 
        push byte '.'                       ;压入立即数（字节）
        
        sub ebp, 4
        cmp ebp, esp                        ;判断压入立即数时，ESP是否减4 
        jnz ghalt                          
        pop eax
        mov [0x1e], al                      ;显示句点 

ghalt:
        ; 已经禁止中断，不会再被唤醒
        hlt

;-------------------------------------------------------------------------------

        gdt_size dw 0
        gdt_base dd 0x00007e00

        times 510-($-$$) db 0
                         db 0x55,0xaa
