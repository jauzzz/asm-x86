; 保护模式：
;   提供了对内存访问的保护
;   实现方式是每次访问内存前先进行检查
;   因此，需要维护一个段的可访问信息表，称为段描述符表
;   其中，全局描述符表，是为整个软硬件系统服务的
;   
; 全局描述符表：
;   全局描述符表存储在内存区域
;   一般来说可以存储在任意内存区域，但由于开机时处于实模式，实模式只能访问 1MB 内存，故一般定义在 1MB 以下的内存范围
;
; 全局描述符表寄存器：
;   计算机中，有一个寄存器，称为全局描述符表寄存器(GDTR)，记录全局描述符表内存区域的起始地址和边界
;   该寄存器为48位，前32位为线性地址，后16位为边界，即边界最大为 2^16 = 65536 字节
;   而一个描述符的大小为 8 字节，故最大可以定义 8192 个描述符
;
;
; 进入保护模式：
;   1. 初始化全局描述符表
;   2. 打开 A20
;   3. 设置 CR0
;   4. 清空流水线并串行化处理器


; ---- 段寄存器初始化 ----
    mov ax, cs
    mov ss, ax
    mov sp, 0x7c00

    ;计算GDT所在的逻辑段地址 
    mov ax, [cs:gdt_base+0x7c00]
    mov dx, [cs:gdt_base+0x7c00+0x02]
    mov bx, 16
    div bx
    mov ds, ax
    mov bx, dx

; ----  初始化全局描述符表 ----
; 一个描述符由两个字组成：包括 32 位的段基地址、20位的段边界、和12位的其他信息
;
; 需要创建四个描述符:
;   1. 空描述符
;   2. 代码段描述符
;   3. 数据段描述符
;   4. 堆栈段描述符

    ;创建0#描述符，是空描述符，这是处理器的要求
    mov dword [bx+0x00], 0x00
    mov dword [bx+0x04], 0x00

    ;创建1#描述符，是代码段描述符
    ;代码段的线性地址是 0x00007c00, 段界限为 0x001FF(512)，粒度是字节（G=0）, 即主引导程序的大小
    mov dword [bx+0x08], 0x7c0001ff
    mov dword [bx+0x0c], 0x00409800

    ;创建2#描述符，是数据段描述符 (文本模式下的显示缓冲区)
    mov dword [bx+0x10],0x8000ffff     
    mov dword [bx+0x14],0x0040920b

    ;创建3#描述符，是堆栈描述符 (从 0x7a00 到 0x7c00) 
    mov dword [bx+0x18],0x00007a00
    mov dword [bx+0x1c],0x00409600

    ;定义完段之后，初始化全局描述符表寄存器 GDTR
    ;4个段，每个段8字节，总共32字节，减一为31字节
    mov word [cs: gdt_size+0x7c00], 31

    lgdt [cs:gdt_size+0x7c00]

; ---- 打开 A20 ----
    in al, 0x92
    or al, 0000_0010B
    out 0x92, al

; ---- 禁止中断 ----
; 保护模式下的中断机制和实模式不同，因此中断向量表不再适用，应重新建立，同时禁止中断
    cli

; ---- 设置 CR0 ----
    mov eax, cr0
    or eax, 1
    mov cr0, eax

; ---- 至此已经进入保护模式 ----
; 但是，有一些手尾要处理：清空流水线并串行化处理器
; 可以通过跳转来实现，跳转对于CPU来说，能同时完成这两项工作

    ; 因为已经进入了保护模式，所以 0x0008 就不是段地址了，而是段选择子
    ; 我们定义了四个段，0x0008 对应的是第一个段，即代码段，也就是当前这个代码文本所属的段
    jmp dword 0x0008:flush

    ; 此处是伪指令: 通知编译器按照 32位操作数模式进行编译
    [bits 32]

flush:
    mov cx, 00000000000_10_000B
    mov ds, cx

    ;以下在屏幕上显示"Protect mode OK." 
    mov byte [0x00],'P'  
    mov byte [0x02],'r'
    mov byte [0x04],'o'
    mov byte [0x06],'t'
    mov byte [0x08],'e'
    mov byte [0x0a],'c'
    mov byte [0x0c],'t'
    mov byte [0x0e],' '
    mov byte [0x10],'m'
    mov byte [0x12],'o'
    mov byte [0x14],'d'
    mov byte [0x16],'e'
    mov byte [0x18],' '
    mov byte [0x1a],'O'
    mov byte [0x1c],'K'

    ;32位保护模式下的堆栈操作
    mov cx,00000000000_11_000B         ;加载堆栈段选择子
    mov ss,cx
    mov esp,0x7c00

    mov ebp, esp
    push byte '.'

    sub ebp, 4
    cmp ebp, esp
    jnz ghalt
    pop eax
    mov [0x1e], al

ghalt:
    hlt    

;-------------------------------------------------------------------------------
     
    gdt_size         dw 0
    gdt_base         dd 0x00007e00     ;GDT的物理地址 
                        
    times 510-($-$$) db 0
                    db 0x55,0xaa
